---
description: "Audio dependency handling rules"
globs: *.py
alwaysApply: false
---
# Audio Dependencies Rules

## Critical Audio Libraries

This project depends on these audio libraries that MUST be available:

### Primary Audio Libraries:

1. **sounddevice** - Real-time audio I/O
   - Used in: [chord_importer/tuner_new.py](mdc:chord_importer/tuner_new.py)
   - Critical modules: `_sounddevice`, `_internal`

2. **numpy** - Numerical computing for audio processing
   - Used throughout audio processing
   - Critical modules: `core`, `linalg`, `fft`

3. **scipy** - Scientific computing for signal processing
   - Used for: Audio filtering, FFT operations
   - Critical modules: `signal`, `io.wavfile`

4. **pyaudio** - Alternative audio I/O
   - Used in: Audio input/output operations

5. **librosa** - Music and audio analysis
   - Dependencies: `numba`, `scikit-learn`, `audioread`

### Import Patterns - REQUIRED:

```python
# ✅ CORRECT - Direct import with proper error handling
import sounddevice as sd
import numpy as np
from scipy import signal

# Fail fast if not available
if not hasattr(sd, 'InputStream'):
    raise ImportError("sounddevice not properly installed")
```

### Import Patterns - FORBIDDEN:

```python
# ❌ FORBIDDEN - Fallback imports
try:
    import sounddevice as sd
except ImportError:
    import pyaudio as sd  # NO FALLBACKS!

# ❌ FORBIDDEN - Conditional functionality
HAS_SOUNDDEVICE = True
try:
    import sounddevice
except ImportError:
    HAS_SOUNDDEVICE = False
```

### Audio Processing Requirements:

- All audio processing MUST work with real audio hardware
- NO mock/dummy audio implementations
- Audio latency MUST be minimized
- Sample rates: Support 44100Hz, 48000Hz minimum

### Testing Audio Dependencies:

Before any audio operation:
1. Verify microphone access
2. Test audio input/output streams
3. Validate sample rate support
4. Check for proper cleanup on exit